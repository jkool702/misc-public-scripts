#!/bin/bash

[[ "$-" == *m* ]] || {
    printf '\nWARNING: timep requires job control to be enabled.\n         Running "set +m" is not allowed!\n         Job control will automatically be re-enabled.\n\n' >&2
    set -m
}
[[ "${FUNCNAME[0]}" == "trap" ]] && ! ${timep_SKIP_DEBUG_FLAG} && {
    timep_SKIP_DEBUG_NEXT_FLAG=true
    ((timep_FNEST_CUR < ${#FUNCNAME[@]})) && {
        timep_BASH_COMMAND_PREV[${timep_FNEST_CUR}]="${BASH_COMMAND}"
        timep_FNEST+=("${#FUNCNAME[@]}")
        timep_FUNCNAME_STR+=".trap"
        timep_NEXEC_0+=".${timep_NEXEC_A[-1]}"
        timep_NEXEC_A+=(0)
        ((timep_NEXEC_N++))
        timep_FNEST_CUR="${#FUNCNAME[@]}"
    }
}
${timep_SKIP_DEBUG_FLAG} || {
    timep_NPIPE[${timep_FNEST_CUR}]=${timep_NPIPE0}
    timep_ENDTIME=${timep_ENDTIME0}
    timep_IS_BG_FLAG=false
    timep_IS_SUBSHELL_FLAG=false
    timep_IS_FUNC_FLAG=false
    if ${timep_SIMPLEFORK_NEXT_FLAG}; then
        timep_SIMPLEFORK_NEXT_FLAG=false
        timep_SIMPLEFORK_CUR_FLAG=true
    else
        timep_SIMPLEFORK_CUR_FLAG=false
    fi
    if ((timep_BASH_SUBSHELL_PREV == BASH_SUBSHELL)); then
        if ((timep_BG_PID_PREV == $!)); then
            ((timep_FNEST_CUR >= ${#FUNCNAME[@]})) || {
                timep_IS_FUNC_FLAG=true
                timep_NO_PRINT_FLAG=true
                timep_FNEST+=("${#FUNCNAME[@]}")
            }
        else
            timep_IS_BG_FLAG=true
        fi
    else
        timep_IS_SUBSHELL_FLAG=true
        echo "${timep_ENDTIME}" >>"${timep_TMPDIR}/.log/.endtimes/${timep_NEXEC_0}.${timep_NEXEC_A[-1]}"
        ((BASHPID < timep_BASHPID_PREV)) && ((timep_NPIDWRAP++))
        builtin trap '' EXIT
        IFS=' ' read -r _ _ _ _ timep_CHILD_PGID _ _ timep_CHILD_TPID _ </proc/${BASHPID}/stat
        ((timep_CHILD_PGID == timep_PARENT_TPID)) || ((timep_CHILD_PGID == timep_CHILD_TPID)) || { ((timep_CHILD_PGID == timep_PARENT_PGID)) && ((timep_CHILD_TPID == timep_PARENT_TPID)); } || timep_IS_BG_FLAG=true
    fi
    if ${timep_IS_SUBSHELL_FLAG} && ${timep_IS_BG_FLAG}; then
        ((timep_CHILD_PGID == BASHPID)) && ((timep_CHILD_TPID == timep_PARENT_PGID)) && ((timep_CHILD_TPID == timep_PARENT_TPID)) && timep_SIMPLEFORK_NEXT_FLAG=true
        timep_CMD_TYPE="BACKGROUND FORK"
    elif ${timep_IS_SUBSHELL_FLAG}; then
        timep_CMD_TYPE="SUBSHELL"
    elif [[ "${timep_BASH_COMMAND_PREV[${timep_FNEST_CUR}]}" == " (F) "* ]]; then
        timep_CMD_TYPE="FUNCTION (P)"
        timep_BASH_COMMAND_PREV[${timep_FNEST_CUR}]="${timep_BASH_COMMAND_PREV[${timep_FNEST_CUR}]# (F) }"
        timep_IS_BG_FLAG=false
    elif ${timep_IS_BG_FLAG}; then
        timep_CMD_TYPE="SIMPLE FORK"
    elif ${timep_IS_FUNC_FLAG_1}; then
        timep_CMD_TYPE="FUNCTION (C)"
        timep_IS_FUNC_FLAG_1=false
    else
        timep_CMD_TYPE="NORMAL COMMAND"
    fi
    if ${timep_IS_SUBSHELL_FLAG}; then
        timep_NPIPE[${timep_FNEST_CUR}]=1
        timep_NPIDWRAP_PREV_0="${timep_NPIDWRAP}"
        ((BASHPID < timep_BASHPID_PREV)) && ((timep_NPIDWRAP_PREV_0++))
        ((timep_BASH_SUBSHELL_DIFF = BASH_SUBSHELL - timep_BASH_SUBSHELL_PREV))
        timep_BASH_COMMAND_PREV_0="<< (${timep_CMD_TYPE}): ${timep_BASHPID_PREV} >>"
        ((timep_NEXEC_N++))
        printf '%s\t%s\t-\tF:%s %s\tS:%s %s\tN:%s %s.%s{%s-%s}\t%s\t::\t%s\n' "${timep_NPIPE[${timep_FNEST_CUR}]}" "${timep_ENDTIME}" "${timep_FNEST_CUR}" "${timep_FUNCNAME_STR}" "${timep_BASH_SUBSHELL_PREV}" "${timep_BASHPID_STR}" "${timep_NEXEC_N}" "${timep_NEXEC_0}" "${timep_NEXEC_A[-1]}" "${timep_NPIDWRAP_PREV_0}" "${BASHPID}" "${timep_LINENO[${timep_FNEST_CUR}]}" "${timep_BASH_COMMAND_PREV_0@Q}" >"${timep_TMPDIR}/.log/log.${timep_NEXEC_0}.${timep_NEXEC_A[-1]}{${timep_NPIDWRAP_PREV_0}-${BASHPID}}.init_r"
        printf '%s\t%s\t%s\tF:%s %s\tS:%s %s\tN:%s %s.%s{%s-%s}.0\t%s\t::\t%s\n' "${timep_NPIPE[${timep_FNEST_CUR}]}" "${EPOCHREALTIME}" "+" "${timep_FNEST_CUR}" "${timep_FUNCNAME_STR}" "${BASH_SUBSHELL}" "${timep_BASHPID_STR}.${BASHPID}" "${timep_NEXEC_N}" "${timep_NEXEC_0}" "${timep_NEXEC_A[-1]}" "${timep_NPIDWRAP_PREV_0}" "${BASHPID}" "${LINENO}" "${BASH_COMMAND@Q}" >"${timep_TMPDIR}/.log/log.${timep_NEXEC_0}.${timep_NEXEC_A[-1]}{${timep_NPIDWRAP_PREV_0}-${BASHPID}}.init_c"
        timep_SUBSHELL_INIT_FLAG=true
        timep_CMD_TYPE_PREV_0="${timep_CMD_TYPE}"
        timep_BASHPID_PREV_0="$BASHPID"
        timep_ENDTIME_PREV_0="${timep_ENDTIME}"
        timep_BASH_SUBSHELL_PREV_0="${timep_BASH_SUBSHELL_PREV}"
        timep_PARENT_PGID="$timep_CHILD_PGID"
        timep_PARENT_TPID="$timep_CHILD_TPID"
    elif ${timep_SUBSHELL_INIT_FLAG}; then
        timep_SUBSHELL_INIT_FLAG=false
        timep_BASHPID_PREV="${timep_BASHPID_PREV_0}"
        timep_BASH_SUBSHELL_PREV="${timep_BASH_SUBSHELL_PREV_0}"
        ((timep_BASH_SUBSHELL_DIFF--))
        timep_BASHPID_ADD=()
        timep_BASHPID_ADD_CUR="${BASHPID}"
        timep_BASHPID_ADD[$timep_BASH_SUBSHELL_DIFF]="${timep_BASHPID_ADD_CUR}"
        timep_KK=1
        while ((timep_BASH_SUBSHELL_DIFF > 0)); do
            ((timep_BASH_SUBSHELL_DIFF--))
            IFS=' ' read -r _ _ _ timep_BASHPID_ADD_CUR _ </proc/${timep_BASHPID_ADD_CUR}/stat
            timep_BASHPID_ADD[${timep_BASH_SUBSHELL_DIFF}]="${timep_BASHPID_ADD_CUR}"
            ((timep_KK++))
        done
        unset "timep_BASH_SUBSHELL_DIFF" "timep_BASH_SUBSHELL_DIFF_0"
        [[ -s "${timep_TMPDIR}/.log/log.${timep_NEXEC_0}.${timep_NEXEC_A[-1]}{${timep_NPIDWRAP_PREV_0}-${BASHPID}}.init_r" ]] && : >"${timep_TMPDIR}/.log/log.${timep_NEXEC_0}.${timep_NEXEC_A[-1]}{${timep_NPIDWRAP_PREV_0}-${BASHPID}}.init_r"
        [[ -s "${timep_TMPDIR}/.log/log.${timep_NEXEC_0}.${timep_NEXEC_A[-1]}{${timep_NPIDWRAP_PREV_0}-${BASHPID}}.init_c" ]] && : >"${timep_TMPDIR}/.log/log.${timep_NEXEC_0}.${timep_NEXEC_A[-1]}{${timep_NPIDWRAP_PREV_0}-${BASHPID}}.init_c"
        timep_KK=0
        while ((timep_KK < ${#timep_BASHPID_ADD[@]})); do
            ((timep_BASHPID_ADD[${timep_KK}] < timep_BASHPID_PREV)) && ((timep_NPIDWRAP++))
            timep_BASHPID_PREV="${timep_BASHPID_ADD[${timep_KK}]}"
            timep_BASH_COMMAND_PREV_0="<< (${timep_CMD_TYPE_PREV_0}): ${timep_BASHPID_PREV} >>"
            printf '%s\t%s\t-\tF:%s %s\tS:%s %s\tN:%s %s.%s{%s-%s}\t%s\t::\t%s\n' "${timep_NPIPE[${timep_FNEST_CUR}]}" "${timep_ENDTIME_PREV_0}" "${timep_FNEST_CUR}" "${timep_FUNCNAME_STR}" "${timep_BASH_SUBSHELL_PREV}" "${timep_BASHPID_STR}" "${timep_NEXEC_N}" "${timep_NEXEC_0}" "${timep_NEXEC_A[-1]}" "${timep_NPIDWRAP}" "${timep_BASHPID_PREV}" "${timep_LINENO[${timep_FNEST_CUR}]}" "${timep_BASH_COMMAND_PREV_0@Q}" >"${timep_TMPDIR}/.log/log.${timep_NEXEC_0}.${timep_NEXEC_A[-1]}{${timep_NPIDWRAP}-${BASHPID}}.init_s"
            timep_BASHPID_STR+=".${timep_BASHPID_PREV}"
            timep_NEXEC_0+=".${timep_NEXEC_A[-1]}{${timep_NPIDWRAP}-${timep_BASHPID_PREV}}"
            timep_NEXEC_A+=(0)
            ((timep_BASH_SUBSHELL_PREV++))
            ((timep_KK++))
        done
        timep_BASHPID_PREV="${timep_BASHPID_ADD[${timep_KK}]}"
        unset "timep_KK" "timep_BASHPID_ADD" "timep_BASH_COMMAND_PREV_0" "timep_NPIDWRAP_PREV_0" "timep_BASH_COMMAND_PREV_0" "timep_CMD_TYPE_PREV_0" "timep_BASHPID_PREV_0" "timep_ENDTIME_PREV_0" "timep_BASH_SUBSHELL_PREV_0"
        ((timep_NEXEC_N++))
    fi
    if ! ${timep_IS_SUBSHELL_FLAG} && ! ${timep_SUBSHELL_INIT_FLAG} && [[ ${timep_BASH_COMMAND_PREV[${timep_FNEST_CUR}]} ]]; then
        ${timep_SIMPLEFORK_CUR_FLAG} && ((BASHPID < $!)) && {
            timep_IS_BG_FLAG=true
            timep_CMD_TYPE="SIMPLE FORK *"
        }
        if ${timep_IS_BG_FLAG}; then
            timep_IS_BG_INDICATOR='(&)'
        else
            timep_IS_BG_INDICATOR=''
        fi
        [[ -s "${timep_TMPDIR}/.log/.endtimes/${timep_NEXEC_0}.${timep_NEXEC_A[-1]}" ]] && {
            {
                while read -r -u ${timep_FD} timep_ENDTIME0; do
                    ((${timep_ENDTIME0//./} < ${timep_ENDTIME//./})) && timep_ENDTIME="${timep_ENDTIME0}"
                done
            } {timep_FD}<"${timep_TMPDIR}/.log/.endtimes/${timep_NEXEC_0}.${timep_NEXEC_A[-1]}"
            exec {timep_FD}>&-
        }
        ${timep_NO_PRINT_FLAG} || printf '%s\t%s\t%s\tF:%s %s\tS:%s %s\tN:%s %s.%s\t%s\t::\t%s %s\n' "${timep_NPIPE[${timep_FNEST_CUR}]}" "${timep_STARTTIME[${timep_FNEST_CUR}]}" "${timep_ENDTIME}" "${timep_FNEST_CUR}" "${timep_FUNCNAME_STR}" "${BASH_SUBSHELL}" "${timep_BASHPID_STR}" "${timep_NEXEC_N}" "${timep_NEXEC_0}" "${timep_NEXEC_A[-1]}" "${timep_LINENO[${timep_FNEST_CUR}]}" "${timep_BASH_COMMAND_PREV[${timep_FNEST_CUR}]@Q}" "${timep_IS_BG_INDICATOR}" >>"${timep_TMPDIR}/.log/log.${timep_NEXEC_0}"
        ((timep_NEXEC_A[-1]++))
        ((timep_NEXEC_N++))
    fi
    ${timep_IS_FUNC_FLAG} && {
        timep_FUNCNAME_STR+=".${FUNCNAME[0]}"
        timep_NEXEC_0+=".${timep_NEXEC_A[-1]}"
        timep_NEXEC_A+=(0)
        ((timep_NEXEC_N++))
        timep_BASH_COMMAND_PREV[${timep_FNEST_CUR}]=" (F) << (FUNCTION): ${BASH_COMMAND} >>"
        timep_LINENO[${timep_FNEST_CUR}]="${LINENO}"
        timep_NPIPE[${#FUNCNAME[@]}]="1"
        timep_FNEST_CUR="${#FUNCNAME[@]}"
        timep_NO_PRINT_FLAG=false
        timep_IS_FUNC_FLAG_1=true
    }
    timep_BASH_COMMAND_PREV[${timep_FNEST_CUR}]="${BASH_COMMAND}"
    timep_LINENO[${timep_FNEST_CUR}]="${LINENO}"
    timep_BG_PID_PREV="$!"
    timep_BASHPID_PREV="$BASHPID"
    ${timep_SKIP_DEBUG_NEXT_FLAG} && {
        timep_SKIP_DEBUG_NEXT_FLAG=false
        timep_SKIP_DEBUG_FLAG=true
    }
    if [[ "$BASH_COMMAND" == exec* ]]; then
        timep_EXEC_ARG="${BASH_COMMAND#*[[:space:]]}"
        timep_EXEC_ARG="${timep_EXEC_ARG%%[[:space:]]*}"
        timep_EXEC_ARG="$(type -p "${timep_EXEC_ARG}")"
        if [[ -x "${timep_EXEC_ARG}" ]] && { [[ "${timep_EXEC_ARG}" == "${timep_BASH_PATH}" ]] || [[ "${timep_EXEC_ARG##*/}" == "bash" ]]; }; then
            timep_SKIP_DEBUG_FLAG=true
            ${timep_NO_PRINT_FLAG} || printf '%s\t%s\t%s\tF:%s %s\tS:%s %s\tN:%s %s.%s\t%s\t::\t%s\n' "${timep_NPIPE[${timep_FNEST_CUR}]}" "${timep_ENDTIME}" "-" "${timep_FNEST_CUR}" "${timep_FUNCNAME_STR}" "${BASH_SUBSHELL}" "${timep_BASHPID_STR}" "${timep_NEXEC_N}" "${timep_NEXEC_0}" "${timep_NEXEC_A[-1]}" "${LINENO}" "<< EXEC BASH: ${BASH_COMMAND@Q} >>" >>"${timep_TMPDIR}/.log/log.${timep_NEXEC_0}"
            timep_BASH_COMMAND_PREV[${timep_FNEST_CUR}]="${BASH_COMMAND}"
            timep_FNEST+=("${#FUNCNAME[@]}")
            timep_FUNCNAME_STR+=".exec"
            timep_NEXEC_0+=".${timep_NEXEC_A[-1]}"
            timep_NEXEC_A+=(0)
            ((timep_NEXEC_N++))
exec() {
    export -f timep
    local -a cmd0=()
    shift 1
    while [[ "$1" == '-'* ]]; do
        case "$1" in
            -o | -O)
                { [[ "$1" == "-o" ]] && [[ "$2" == "monitor" ]]; } || { [[ "$1" == "-O" ]] && [[ "$2" == "extglob" ]]; } || { [[ "$1" == "-O" ]] && [[ "$2" == "functrace" ]]; } || cmd0+=("$1" "$2")
                shift 2
                ;;
            -c | --)
                shift 1
                break
                ;;
            *)
                [[ "$1" == [+-]m ]] || [[ "$1" == [+-]i ]] || cmd0+=("$1")
                shift 1
                ;;
        esac
    done
    unset exec
    if [[ -t 0 ]]; then
        timep_TMPDIR="${timep_TMPDIR}/.exec/${timep_NEXEC_0}" builtin exec "${BASH}" -m -O extglob -o functrace "${cmd0[@]}" -c 'timep "${@}"' _ "${@}"
    else
        timep_TMPDIR="${timep_TMPDIR}/.exec/${timep_NEXEC_0}" builtin exec "${BASH}" -m -O extglob -o functrace "${cmd0[@]}" -c 'timep "${@}" <&0' _ "${@}"
    fi
}
        fi
    fi
    timep_STARTTIME[${timep_FNEST_CUR}]="${EPOCHREALTIME}"
}
